# leetcode
开始刷题啦！！！

680		可以优化成子函数模式！

88		两个有序数组合并为一个数组时，注意从尾部开始比较！

141		成环的问题，考虑使用快慢指针法，一个指针走两步，另一个指针走一步，有环两个指针必定会相遇。

215		快排要自己能写出来

347		o（nlog2n）的时间复杂度大于o（n），n越大差距越大，排序算法时间复杂度最小就是o（nlog2n）。大顶堆，小顶堆，优先级队列使用场景，频率最高的前k个元素，仿函数的构建

451 	频率,排序相关的问题都可以考虑 map统计频率，设置顶堆方式，优先级队列，来做

75		关键是如何只做一次遍历，且原地排序 0，1，2. 核心在于用2个or3个指针，分别指向0，1，2三个数字的起始或者结束位置。

435		给子函数传递值的时候，记得把vector变量加一个引用传递，这样就不用额外复制一次这个变量到内存里，执行速度会快很多

665		当vector中两个相邻的元素相互比较，然后需要修改其中某一个的时候，一定要想清除，修改前面的，还是后面的；可以两种都试试，如果有一个成果结果就算成果。或者看看是否根据联系再前一个元素和再后一个元素，就可以判断到底要改哪个元素了。

665		(if (i - 2 >= 0 && nums[i - 2] > nums[i]))	可以这样判断边界情况！！！防止 i-2 或者 i+2 超出数组索引范围

69		需要解决运算溢出： int a,b   a*b > x，这里a*b的运算可能会溢出2的31次方，因此可以改为，a>x / b,这样运算的结果就不会溢出了，另外 x/b会被向下取整，因此可以再改为 x/(b*1.0)，转为浮点运算，保留小数

744		二分法使用while循环做，设立left和right，当right和left距离不足1时，就退出循环，手动判断left和right哪个是需要的数据。 *用二分法还有一个核心是，如何判断那个区间是下一批迭代的区间*