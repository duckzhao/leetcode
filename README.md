# leetcode
开始刷题啦！！！

680		可以优化成子函数模式！

88		两个有序数组合并为一个数组时，注意从尾部开始比较！

141		成环的问题，考虑使用快慢指针法，一个指针走两步，另一个指针走一步，有环两个指针必定会相遇。

215		快排要自己能写出来

347		o（nlog2n）的时间复杂度大于o（n），n越大差距越大，排序算法时间复杂度最小就是o（nlog2n）。大顶堆，小顶堆，优先级队列使用场景，频率最高的前k个元素，仿函数的构建

451 	频率,排序相关的问题都可以考虑 map统计频率，设置顶堆方式，优先级队列，来做

75		关键是如何只做一次遍历，且原地排序 0，1，2. 核心在于用2个or3个指针，分别指向0，1，2三个数字的起始或者结束位置。

435		给子函数传递值的时候，记得把vector变量加一个引用传递，这样就不用额外复制一次这个变量到内存里，执行速度会快很多

665		当vector中两个相邻的元素相互比较，然后需要修改其中某一个的时候，一定要想清除，修改前面的，还是后面的；可以两种都试试，如果有一个成果结果就算成果。或者看看是否根据联系再前一个元素和再后一个元素，就可以判断到底要改哪个元素了。

665		(if (i - 2 >= 0 && nums[i - 2] > nums[i]))	可以这样判断边界情况！！！防止 i-2 或者 i+2 超出数组索引范围

69		需要解决运算溢出： int a,b   a*b > x，这里a*b的运算可能会溢出2的31次方，因此可以改为，a>x / b,这样运算的结果就不会溢出了，另外 x/b会被向下取整，因此可以再改为 x/(b*1.0)，转为浮点运算，保留小数

744		二分法使用while循环做，设立left和right，当right和left距离不足1时，就退出循环，手动判断left和right哪个是需要的数据。 *用二分法还有一个核心是，如何判断那个区间是下一批迭代的区间*

241		递归、迭代、回溯算法核心是：如何将原始的大的问题，拆解为多个类似的小问题，一步一步拆下来，可以55拆解，也可以19拆解，1就是递归问题的退出边界。      ①定义好递归函数的参数；②定义好递归函数的退出条件；③子进程的返回值如何在当前进程中使用；

95		回溯的时候，定义的子函数参数大多数都是[left, right]，然后一直分解left right，直到两个相等或者left+1=right；所以思考问题可以朝着这个方向

回溯算法的模板框架
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
